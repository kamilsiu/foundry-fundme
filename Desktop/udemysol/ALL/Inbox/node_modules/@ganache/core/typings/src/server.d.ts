import type { AnyFlavor } from "@ganache/flavor";
import Emittery from "emittery";
export type { Provider } from "../index";
import type EthereumFlavor from "@ganache/ethereum";
import { ServerOptions } from "./types";
export type Callback = (err: Error | null) => void;
/**
 * Server ready state constants.
 *
 * These are bit flags. This means that you can check if the status is:
 *  * ready: `status === ServerStatus.ready` or `status & ServerStatus.ready !== 0`
 *  * opening: `status === ServerStatus.opening` or `status & ServerStatus.opening !== 0`
 *  * open: `status === ServerStatus.open` or `status & ServerStatus.open !== 0`
 *  * opening || open: `status & ServerStatus.openingOrOpen !== 0` or `status & (ServerStatus.opening | ServerStatus.open) !== 0`
 *  * closing: `status === ServerStatus.closing` or `status & ServerStatus.closing !== 0`
 *  * closed: `status === ServerStatus.closed` or `status & ServerStatus.closed !== 0`
 *  * closing || closed: `status & ServerStatus.closingOrClosed !== 0` or `status & (ServerStatus.closing | ServerStatus.closed) !== 0`
 */
export declare enum ServerStatus {
    /**
     * The Server is in an unknown state; perhaps construction didn't succeed
     */
    unknown = 0,
    /**
     * The Server has been constructed and is ready to be opened.
     */
    ready = 1,
    /**
     * The Server has started to open, but has not yet finished initialization.
     */
    opening = 2,
    /**
     * The Server is open and ready for connection.
     */
    open = 4,
    /**
     * The Server is either opening or is already open
     */
    openingOrOpen = 6,
    /**
     * The Server is in the process of closing.
     */
    closing = 8,
    /**
     * The Server is closed and not accepting new connections.
     */
    closed = 16,
    /**
     * The Server is either opening or is already open
     */
    closingOrClosed = 24
}
/**
 * @public
 */
export declare class Server<F extends AnyFlavor = EthereumFlavor> extends Emittery<{
    open: undefined;
    close: undefined;
}> {
    #private;
    get provider(): ReturnType<F["connect"]>["provider"];
    get status(): number;
    constructor(options?: ServerOptions<F>);
    listen(port: number): Promise<void>;
    listen(port: number, host: string): Promise<void>;
    listen(port: number, callback: Callback): void;
    listen(port: number, host: string, callback: Callback): void;
    address(): {
        address: string;
        family: string;
        port: number;
    };
    close(): Promise<void>;
}
export default Server;
//# sourceMappingURL=server.d.ts.map