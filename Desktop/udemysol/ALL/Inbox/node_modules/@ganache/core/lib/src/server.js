"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Server_options, _Server_status, _Server_app, _Server_httpServer, _Server_listenSocket, _Server_host, _Server_connector, _Server_websocketServer, _Server_initializer;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = exports.ServerStatus = void 0;
const aggregate_error_1 = __importDefault(require("aggregate-error"));
const uws_js_unofficial_1 = require("@trufflesuite/uws-js-unofficial");
// Set the "silent" config option so we don't output the "uwebsockets" header
// we check for truthiness because `uws` is omitted from the browser build
uws_js_unofficial_1._cfg &&
    (0, uws_js_unofficial_1._cfg)(new Uint8Array([115, 105, 108, 101, 110, 116]));
const flavor_1 = require("@ganache/flavor");
const connector_loader_1 = require("./connector-loader");
const ws_server_1 = __importDefault(require("./servers/ws-server"));
const http_server_1 = __importDefault(require("./servers/http-server"));
const emittery_1 = __importDefault(require("emittery"));
// not using the "net" node package in order to avoid having to polyfill this
// for the browser build.
// isIPv4 taken from https://github.com/nodejs/node/blob/01323d50c4b24cf730a651d06ba20633905ecbed/lib/internal/net.js#L31
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const IPv4Reg = new RegExp(`^(${v4Seg}[.]){3}${v4Seg}$`);
const isIPv4 = (s) => IPv4Reg.test(s);
const DEFAULT_HOST = "127.0.0.1";
/**
 * Server ready state constants.
 *
 * These are bit flags. This means that you can check if the status is:
 *  * ready: `status === ServerStatus.ready` or `status & ServerStatus.ready !== 0`
 *  * opening: `status === ServerStatus.opening` or `status & ServerStatus.opening !== 0`
 *  * open: `status === ServerStatus.open` or `status & ServerStatus.open !== 0`
 *  * opening || open: `status & ServerStatus.openingOrOpen !== 0` or `status & (ServerStatus.opening | ServerStatus.open) !== 0`
 *  * closing: `status === ServerStatus.closing` or `status & ServerStatus.closing !== 0`
 *  * closed: `status === ServerStatus.closed` or `status & ServerStatus.closed !== 0`
 *  * closing || closed: `status & ServerStatus.closingOrClosed !== 0` or `status & (ServerStatus.closing | ServerStatus.closed) !== 0`
 */
var ServerStatus;
(function (ServerStatus) {
    /**
     * The Server is in an unknown state; perhaps construction didn't succeed
     */
    ServerStatus[ServerStatus["unknown"] = 0] = "unknown";
    /**
     * The Server has been constructed and is ready to be opened.
     */
    ServerStatus[ServerStatus["ready"] = 1] = "ready";
    /**
     * The Server has started to open, but has not yet finished initialization.
     */
    ServerStatus[ServerStatus["opening"] = 2] = "opening";
    /**
     * The Server is open and ready for connection.
     */
    ServerStatus[ServerStatus["open"] = 4] = "open";
    /**
     * The Server is either opening or is already open
     */
    ServerStatus[ServerStatus["openingOrOpen"] = 6] = "openingOrOpen";
    /**
     * The Server is in the process of closing.
     */
    ServerStatus[ServerStatus["closing"] = 8] = "closing";
    /**
     * The Server is closed and not accepting new connections.
     */
    ServerStatus[ServerStatus["closed"] = 16] = "closed";
    /**
     * The Server is either opening or is already open
     */
    ServerStatus[ServerStatus["closingOrClosed"] = 24] = "closingOrClosed";
})(ServerStatus || (exports.ServerStatus = ServerStatus = {}));
/**
 * @public
 */
class Server extends emittery_1.default {
    get provider() {
        return __classPrivateFieldGet(this, _Server_connector, "f").provider;
    }
    get status() {
        return __classPrivateFieldGet(this, _Server_status, "f");
    }
    constructor(options = {
        flavor: "ethereum"
    }) {
        super();
        _Server_options.set(this, void 0);
        _Server_status.set(this, ServerStatus.unknown);
        _Server_app.set(this, null);
        _Server_httpServer.set(this, null);
        _Server_listenSocket.set(this, null);
        _Server_host.set(this, null);
        _Server_connector.set(this, void 0);
        _Server_websocketServer.set(this, null);
        _Server_initializer.set(this, void 0);
        __classPrivateFieldSet(this, _Server_status, ServerStatus.ready, "f");
        // we need to start initializing now because the connector's `#provider
        // property must be available to the server immediately... someone might
        // want to do:
        // ```
        // const server = Ganache.server();
        // const provider = server.provider; // this needs to exist
        // await server.listen(8545)
        // ```
        const { flavor, connector, promise } = (0, connector_loader_1.initializeFlavor)(options);
        __classPrivateFieldSet(this, _Server_connector, connector, "f");
        let serverOptions = flavor_1.ServerOptionsConfig.normalize(options);
        // etheruem flavor options are the defaults, so only merge for non-ethereum
        if (flavor.flavor !== "ethereum" && flavor.options.server) {
            serverOptions = {
                ...serverOptions,
                ...flavor.options.server.normalize(options)
            };
        }
        __classPrivateFieldSet(this, _Server_options, serverOptions, "f");
        const _app = (__classPrivateFieldSet(this, _Server_app, (0, uws_js_unofficial_1.App)(), "f"));
        if (serverOptions.server.ws) {
            __classPrivateFieldSet(this, _Server_websocketServer, new ws_server_1.default(_app, connector, serverOptions.server), "f");
        }
        __classPrivateFieldSet(this, _Server_httpServer, new http_server_1.default(_app, connector, __classPrivateFieldGet(this, _Server_options, "f").server), "f");
        // Since `loadConnector` starts an async promise that we intentionally
        // don't await yet we keep the promise around for `listen` to handle
        // later.
        __classPrivateFieldSet(this, _Server_initializer, promise, "f");
    }
    listen(port, host, callback) {
        if (typeof host === "function") {
            callback = host;
            host = null;
        }
        const callbackIsFunction = typeof callback === "function";
        // Method signature specifies port: number, but we parse a string if provided
        // inspiration taken from nodejs internal port validator
        // https://github.com/nodejs/node/blob/8c4b8b201ada6b76d5306c9c7f352e45087fb4a9/lib/internal/validators.js#L208-L219
        if ((typeof port !== "number" && typeof port !== "string") ||
            (typeof port === "string" && port.trim().length === 0) ||
            +port !== +port >>> 0 ||
            port > 0xffff) {
            const err = new Error(`Port should be >= 0 and < 65536. Received ${port}.`);
            return callbackIsFunction
                ? process.nextTick(callback, err)
                : Promise.reject(err);
        }
        const portNumber = +port;
        const status = __classPrivateFieldGet(this, _Server_status, "f");
        if (status === ServerStatus.closing) {
            // if closing
            const err = new Error(`Cannot start server while it is closing.`);
            return callbackIsFunction
                ? process.nextTick(callback, err)
                : Promise.reject(err);
        }
        else if ((status & ServerStatus.openingOrOpen) !== 0) {
            // if opening or open
            const err = new Error(`Server is already open, or is opening, on port: ${portNumber}.`);
            return callbackIsFunction
                ? process.nextTick(callback, err)
                : Promise.reject(err);
        }
        __classPrivateFieldSet(this, _Server_status, ServerStatus.opening, "f");
        const initializer = __classPrivateFieldGet(this, _Server_initializer, "f");
        // don't keep old promises around as they could be holding onto
        // references to things that could otherwise be collected.
        __classPrivateFieldSet(this, _Server_initializer, null, "f");
        const promise = Promise.allSettled([
            initializer,
            new Promise((resolve) => {
                // Make sure we have *exclusive* use of this port.
                // https://github.com/uNetworking/uSockets/commit/04295b9730a4d413895fa3b151a7337797dcb91f#diff-79a34a07b0945668e00f805838601c11R51
                const LIBUS_LISTEN_EXCLUSIVE_PORT = 1;
                host
                    ? __classPrivateFieldGet(this, _Server_app, "f").listen(host, portNumber, LIBUS_LISTEN_EXCLUSIVE_PORT, resolve)
                    : __classPrivateFieldGet(this, _Server_app, "f").listen(portNumber, LIBUS_LISTEN_EXCLUSIVE_PORT, resolve);
            }).then(listenSocket => {
                if (listenSocket) {
                    __classPrivateFieldSet(this, _Server_status, ServerStatus.open, "f");
                    __classPrivateFieldSet(this, _Server_listenSocket, listenSocket, "f");
                    __classPrivateFieldSet(this, _Server_host, host || DEFAULT_HOST, "f");
                }
                else {
                    __classPrivateFieldSet(this, _Server_status, ServerStatus.closed, "f");
                    const err = new Error(`listen EADDRINUSE: address already in use ${host || DEFAULT_HOST}:${portNumber}.`);
                    // emulate part of node's EADDRINUSE error:
                    err.code = "EADDRINUSE";
                    throw err;
                }
            })
        ]).then(async (promiseResults) => {
            const errors = [];
            if (promiseResults[0].status === "rejected") {
                errors.push(promiseResults[0].reason);
            }
            if (promiseResults[1].status === "rejected") {
                errors.push(promiseResults[1].reason);
            }
            if (errors.length === 0) {
                this.emit("open");
            }
            else {
                __classPrivateFieldSet(this, _Server_status, ServerStatus.unknown, "f");
                try {
                    await this.close();
                }
                catch (e) {
                    errors.push(e);
                }
                if (errors.length > 1) {
                    throw new aggregate_error_1.default(errors);
                }
                else {
                    throw errors[0];
                }
            }
        });
        if (callbackIsFunction) {
            promise.then(() => callback(null)).catch(callback);
        }
        else {
            return promise;
        }
    }
    address() {
        if (__classPrivateFieldGet(this, _Server_listenSocket, "f")) {
            const address = __classPrivateFieldGet(this, _Server_host, "f");
            return {
                address,
                family: isIPv4(address) ? "IPv4" : "IPv6",
                port: (0, uws_js_unofficial_1.us_socket_local_port)(__classPrivateFieldGet(this, _Server_listenSocket, "f"))
            };
        }
        else {
            return null;
        }
    }
    async close() {
        if (__classPrivateFieldGet(this, _Server_status, "f") === ServerStatus.opening) {
            // if opening
            throw new Error(`Cannot close server while it is opening.`);
        }
        else if ((__classPrivateFieldGet(this, _Server_status, "f") & ServerStatus.closingOrClosed) !== 0) {
            // if closing or closed
            throw new Error(`Server is already closing or closed.`);
        }
        __classPrivateFieldSet(this, _Server_status, ServerStatus.closing, "f");
        // clean up the websocket objects
        const _listenSocket = __classPrivateFieldGet(this, _Server_listenSocket, "f");
        __classPrivateFieldSet(this, _Server_listenSocket, null, "f");
        // close the socket to prevent any more connections
        if (_listenSocket !== null) {
            (0, uws_js_unofficial_1.us_listen_socket_close)(_listenSocket);
        }
        // close all the connected websockets:
        if (__classPrivateFieldGet(this, _Server_websocketServer, "f") !== null) {
            __classPrivateFieldGet(this, _Server_websocketServer, "f").close();
        }
        // and do all http cleanup, if any
        if (__classPrivateFieldGet(this, _Server_httpServer, "f") !== null) {
            __classPrivateFieldGet(this, _Server_httpServer, "f").close();
        }
        // cleanup the connector, provider, etc.
        if (__classPrivateFieldGet(this, _Server_connector, "f") !== null) {
            await __classPrivateFieldGet(this, _Server_connector, "f").close();
        }
        // calling `close()` on the app closes any idle connections immediately,
        // this is neccessary because keepAlive connections can keep the server
        // open indefintely even after the listen socket is closed.
        // TODO: add a `close` is our uws fork fallback:
        __classPrivateFieldGet(this, _Server_app, "f").close && __classPrivateFieldGet(this, _Server_app, "f").close();
        __classPrivateFieldSet(this, _Server_status, ServerStatus.closed, "f");
        __classPrivateFieldSet(this, _Server_app, null, "f");
        await this.emit("close");
    }
}
exports.Server = Server;
_Server_options = new WeakMap(), _Server_status = new WeakMap(), _Server_app = new WeakMap(), _Server_httpServer = new WeakMap(), _Server_listenSocket = new WeakMap(), _Server_host = new WeakMap(), _Server_connector = new WeakMap(), _Server_websocketServer = new WeakMap(), _Server_initializer = new WeakMap();
exports.default = Server;
//# sourceMappingURL=server.js.map