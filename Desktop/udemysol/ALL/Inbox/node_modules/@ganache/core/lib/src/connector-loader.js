"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeFlavor = void 0;
const utils_1 = require("@ganache/utils");
const flavor_1 = require("@ganache/flavor");
function loadFlavorByName(flavorName) {
    if (flavorName === "ethereum") {
        // lazy load the ethereum flavor to avoid start up overhead for
        // other flavors.
        return require("@ganache/ethereum").default;
    }
    return (0, flavor_1.load)(flavorName);
}
function getConnector(flavor, providerOptions, executor) {
    return flavor.connect(providerOptions, executor);
}
/**
 * Loads the connector specified by the given `options.flavor` with the given
 * options, or the `ethereum` flavor is `options.flavor` is not specified.
 * @param options
 * @returns
 */
const initializeFlavor = (options = {
    flavor: "ethereum"
}) => {
    const flavorName = (options.flavor || "ethereum");
    // Set up our request coordinator to either use FIFO or or async request
    // processing. The RequestCoordinator _can_ be used to coordinate the number
    // of requests being processed, but we don't use it for that (yet), instead
    // of "all" (0) or just 1 as we are doing here:
    let asyncRequestProcessing;
    if ("chain" in options &&
        "asyncRequestProcessing" in options.chain) {
        asyncRequestProcessing = options.chain["asyncRequestProcessing"];
    }
    else if ("asyncRequestProcessing" in options) {
        asyncRequestProcessing = options["asyncRequestProcessing"];
    }
    else {
        asyncRequestProcessing = true;
    }
    const requestCoordinator = new utils_1.RequestCoordinator(asyncRequestProcessing ? 0 : 1);
    // The Executor is responsible for actually executing the method on the
    // chain/API. It performs some safety checks to ensure "safe" method
    //  execution before passing it to a RequestCoordinator.
    const executor = new utils_1.Executor(requestCoordinator);
    const flavor = loadFlavorByName(flavorName);
    const connector = getConnector(flavor, options, executor);
    // Purposely not awaiting on this to prevent a breaking change
    // to the `Ganache.provider()` method
    const connectPromise = connector.connect();
    // The request coordinator is initialized in a "paused" state; when the
    // provider is ready we unpause.. This lets us accept queue requests before
    // we've even fully initialized.
    // The function referenced by requestcoordinator.resume will be changed when
    // requestCoordinator.stop() is called. Ensure that no references to the
    // function are held, otherwise internal errors may be surfaced.
    return {
        flavor,
        connector,
        promise: connectPromise.then(() => requestCoordinator.resume())
    };
};
exports.initializeFlavor = initializeFlavor;
//# sourceMappingURL=connector-loader.js.map