"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rawFromRpc = exports.serializeForDb = exports.serializeRpcForDb = void 0;
const utils_1 = require("@ganache/utils");
const ethereum_address_1 = require("@ganache/ethereum-address");
const rlp_1 = require("@ganache/rlp");
const rpc_transaction_1 = require("./rpc-transaction");
const access_lists_1 = require("./access-lists");
const ethereum_utils_1 = require("@ganache/ethereum-utils");
function serializeRpcForDb(tx, blockHash, blockNumber, transactionIndex) {
    let type;
    if (!("type" in tx) || tx.type === undefined) {
        type = rpc_transaction_1.TransactionType.Legacy;
    }
    else {
        type = parseInt(tx.type, 16);
    }
    const txData = {
        raw: rawFromRpc(tx, type),
        from: ethereum_address_1.Address.from(tx.from),
        hash: utils_1.Data.from(tx.hash, 32),
        // this assumes that gasPrice has been set - even for EIP-1559 Fee Market transactions
        effectiveGasPrice: utils_1.Quantity.from(tx.gasPrice),
        type: utils_1.Quantity.from(type)
    };
    return serializeForDb(txData, blockHash, blockNumber, transactionIndex);
}
exports.serializeRpcForDb = serializeRpcForDb;
function serializeForDb(tx, blockHash, blockNumber, transactionIndex) {
    const legacy = tx.raw.length === 9;
    // todo(perf):make this work with encodeRange and digest
    const txAndExtraData = [
        // todo: this is encoded differently in the tx table than it is in the
        // block table. we should migrate the tx table to use the same format as
        // the block (`Buffer.concat([type, encode(raw)])`) so that we can avoid
        // block it twice for each block save step.
        legacy ? tx.raw : [tx.type.toBuffer(), ...tx.raw],
        [
            tx.from.buf,
            tx.hash.toBuffer(),
            blockHash.toBuffer(),
            blockNumber.toBuffer(),
            transactionIndex.toBuffer(),
            tx.effectiveGasPrice.toBuffer()
        ]
    ];
    return (0, rlp_1.encode)(txAndExtraData);
}
exports.serializeForDb = serializeForDb;
function rawFromRpc(txData, txType) {
    const chainId = utils_1.Quantity.toBuffer(txData.chainId);
    const nonce = utils_1.Quantity.toBuffer(txData.nonce);
    const gasPrice = utils_1.Quantity.toBuffer(txData.gasPrice);
    const gasLimit = utils_1.Quantity.toBuffer(txData.gas || txData.gasLimit);
    // todo: use Address type
    const to = utils_1.Data.toBuffer(txData.to, 20);
    const value = utils_1.Quantity.toBuffer(txData.value);
    const data = utils_1.Data.toBuffer(txData.data || txData.input);
    const v = utils_1.Data.toBuffer(txData.v);
    const r = utils_1.Data.toBuffer(txData.r);
    const s = utils_1.Data.toBuffer(txData.s);
    // if no access list is provided, we convert to legacy
    const targetType = txType === rpc_transaction_1.TransactionType.EIP2930AccessList &&
        txData.accessList === undefined
        ? rpc_transaction_1.TransactionType.Legacy
        : txType;
    switch (targetType) {
        case rpc_transaction_1.TransactionType.Legacy:
            return [nonce, gasPrice, gasLimit, to, value, data, v, r, s];
        case rpc_transaction_1.TransactionType.EIP2930AccessList:
            return [
                chainId,
                nonce,
                gasPrice,
                gasLimit,
                to,
                value,
                data,
                // accesslists is _always_ set, otherwise it's legacy
                txData.accessList
                    ? access_lists_1.AccessLists.getAccessListData(txData.accessList).accessList
                    : [],
                v,
                r,
                s
            ];
        // todo: should this be TransactionType.EIP1559FeeMarket?
        case rpc_transaction_1.TransactionType.EIP1559AccessList:
            return [
                chainId,
                nonce,
                utils_1.Quantity.toBuffer(txData.maxPriorityFeePerGas),
                utils_1.Quantity.toBuffer(txData.maxFeePerGas),
                gasLimit,
                to,
                value,
                data,
                txData.accessList
                    ? access_lists_1.AccessLists.getAccessListData(txData.accessList).accessList
                    : [],
                v,
                r,
                s
            ];
        default:
            throw new ethereum_utils_1.CodedError("Tx instantiation with supplied type not supported", utils_1.JsonRpcErrorCode.METHOD_NOT_FOUND);
    }
}
exports.rawFromRpc = rawFromRpc;
//# sourceMappingURL=transaction-serialization.js.map