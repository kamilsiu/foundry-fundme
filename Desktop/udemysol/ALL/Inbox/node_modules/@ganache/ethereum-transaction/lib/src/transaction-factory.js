"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionFactory = void 0;
const utils_1 = require("@ganache/utils");
const legacy_transaction_1 = require("./legacy-transaction");
const eip2930_access_list_transaction_1 = require("./eip2930-access-list-transaction");
const rpc_transaction_1 = require("./rpc-transaction");
const rlp_1 = require("@ganache/rlp");
const ethereum_utils_1 = require("@ganache/ethereum-utils");
const eip1559_fee_market_transaction_1 = require("./eip1559-fee-market-transaction");
const secp256k1_1 = require("@ganache/secp256k1");
/**
 * @param common
 * @param tx
 * @throws
 */
function assertValidTransactionSValue(common, tx) {
    // Transaction signatures whose s-value is greater than secp256k1n/2 are
    // invalid after EIP-2 hardfork (homestead). See: https://eips.ethereum.org/EIPS/eip-2
    if (tx.s &&
        tx.s.toBigInt() >= secp256k1_1.SECP256K1_MAX_PRIVATE_KEY_DIV_2 &&
        // EIP-2 is in homestead, but we can't use isActivatedEIP(2) because
        // Common doesn't have that information for this hardfork.
        common.gteHardfork("homestead")) {
        throw new Error("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
    }
}
class TransactionFactory {
    constructor(raw, common) {
        const [txData, extra] = (0, rlp_1.decode)(raw);
        this.tx = TransactionFactory.fromDatabaseTx(txData, common, extra);
    }
    /**
     * Validates the txType against active hardforks and EIPs. May
     * coerce transactions to a transaction type that differs from the specified
     * txType. For example, if the txType is EIP2930AccessList but the hardfork
     * is before EIP-2930 is activated, the txType will be coerced to Legacy.
     *
     * @param txData
     * @param txType
     * @param common
     * @param extra
     * @returns
     */
    static _fromUnsafeUserData(txData, txType, common, extra) {
        // if tx type envelope isn't available yet on this HF,
        // return legacy txs as is and convert typed txs to legacy
        if (!common.isActivatedEIP(2718)) {
            return legacy_transaction_1.LegacyTransaction.fromTxData(txData, common, extra);
        }
        else if (!common.isActivatedEIP(1559)) {
            if (txType === rpc_transaction_1.TransactionType.Legacy) {
                return legacy_transaction_1.LegacyTransaction.fromTxData(txData, common, extra);
            }
            else if (txType === rpc_transaction_1.TransactionType.EIP2930AccessList) {
                if (common.isActivatedEIP(2930)) {
                    return eip2930_access_list_transaction_1.EIP2930AccessListTransaction.fromTxData((txData), common, extra);
                }
                else {
                    // TODO: I believe this is unreachable with current architecture.
                    // If 2718 is supported, so is 2930.
                    // Issue: https://github.com/trufflesuite/ganache/issues/3487
                    throw new ethereum_utils_1.CodedError(`EIP 2930 is not activated.`, utils_1.JsonRpcErrorCode.INVALID_PARAMS);
                }
            }
            else if (txType === rpc_transaction_1.TransactionType.EIP1559AccessList) {
                throw new ethereum_utils_1.CodedError(`EIP 1559 is not activated.`, utils_1.JsonRpcErrorCode.INVALID_PARAMS);
            }
        }
        // eip 1559, 2930, and 2718 are activated
        else {
            // we can assume that all database transactions came from us, so
            // the type doesn't need to be normalized.
            if (Array.isArray(txData)) {
                if (txType === rpc_transaction_1.TransactionType.Legacy) {
                    return legacy_transaction_1.LegacyTransaction.fromTxData(txData, common, extra);
                }
                else if (txType === rpc_transaction_1.TransactionType.EIP2930AccessList) {
                    return eip2930_access_list_transaction_1.EIP2930AccessListTransaction.fromTxData(txData, common, extra);
                }
                else if (txType === rpc_transaction_1.TransactionType.EIP1559AccessList) {
                    return eip1559_fee_market_transaction_1.EIP1559FeeMarketTransaction.fromTxData(txData, common, extra);
                }
            }
            else {
                const toEIP1559 = (txType === rpc_transaction_1.TransactionType.Legacy ||
                    txType === rpc_transaction_1.TransactionType.EIP2930AccessList) &&
                    txData.gasPrice === undefined;
                if (txType === rpc_transaction_1.TransactionType.EIP1559AccessList || toEIP1559) {
                    const tx = eip1559_fee_market_transaction_1.EIP1559FeeMarketTransaction.fromTxData(txData, common, extra);
                    if (toEIP1559) {
                        // they didn't specify the type as eip-1559 (type 2), so we are
                        // upgrading it. BUT, there's still a chance they sent us this data,
                        // so we don't want to overwrite it.
                        if (!txData.maxFeePerGas) {
                            tx.maxFeePerGas = utils_1.Quantity.from(null);
                        }
                        if (!txData.maxPriorityFeePerGas) {
                            tx.maxPriorityFeePerGas = utils_1.Quantity.Gwei;
                        }
                    }
                    return tx;
                }
                else if (txType === rpc_transaction_1.TransactionType.Legacy) {
                    return legacy_transaction_1.LegacyTransaction.fromTxData(txData, common, extra);
                }
                else if (txType === rpc_transaction_1.TransactionType.EIP2930AccessList) {
                    // if no access list is provided, we convert to legacy
                    if (txData.accessList === undefined) {
                        return legacy_transaction_1.LegacyTransaction.fromTxData(txData, common, extra);
                    }
                    else {
                        return eip2930_access_list_transaction_1.EIP2930AccessListTransaction.fromTxData(txData, common, extra);
                    }
                }
            }
        }
        throw new ethereum_utils_1.CodedError(`Tx instantiation with supplied type not supported`, utils_1.JsonRpcErrorCode.METHOD_NOT_FOUND);
    }
    /**
     * Create a transaction from a `txData` object
     *
     * @param txData - The rpc transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
     * @param common - Options to pass on to the constructor of the transaction
     */
    static fromRpc(txData, common, extra) {
        const txType = this.typeOfRPC(txData);
        const tx = this._fromUnsafeUserData(txData, txType, common, extra);
        assertValidTransactionSValue(common, tx);
        return tx;
    }
    /**
     * Create a transaction from a `txData` object
     *
     * @param txData - The raw transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
     * @param common - Options to pass on to the constructor of the transaction
     */
    static fromDatabaseTx(txData, common, extra) {
        const txType = this.typeOfRaw(txData);
        switch (txType) {
            case rpc_transaction_1.TransactionType.EIP1559AccessList:
                return eip1559_fee_market_transaction_1.EIP1559FeeMarketTransaction.fromTxData(txData.slice(1), common, extra);
            case rpc_transaction_1.TransactionType.Legacy:
                return legacy_transaction_1.LegacyTransaction.fromTxData(txData, common, extra);
            case rpc_transaction_1.TransactionType.EIP2930AccessList:
                return eip2930_access_list_transaction_1.EIP2930AccessListTransaction.fromTxData(txData.slice(1), common, extra);
            default:
                throw new ethereum_utils_1.CodedError(`Transactions with supplied type ${txType} not supported`, utils_1.JsonRpcErrorCode.METHOD_NOT_FOUND);
        }
    }
    /**
     * Create a transaction from a `txData` object without the type field in the first position (for type 1 and 2 txs)
     *
     * This method should only be used with "safe" data that doesn't need to be validated against the active hardforks or
     * EIPs. In other words: it should come from a fork, or from the database.
     *
     * @tparam txTYpe - The type of txData. Throws if the the type is not supported.
     * @param txData - The raw transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
     * @param common - Options to pass on to the constructor of the transaction
     * @param extra
     */
    static fromSafeTypeAndTxData(txType, txData, common, extra) {
        switch (txType) {
            case rpc_transaction_1.TransactionType.EIP1559AccessList:
                return eip1559_fee_market_transaction_1.EIP1559FeeMarketTransaction.fromTxData(txData, common, extra);
            case rpc_transaction_1.TransactionType.Legacy:
                return legacy_transaction_1.LegacyTransaction.fromTxData(txData, common, extra);
            case rpc_transaction_1.TransactionType.EIP2930AccessList:
                return eip2930_access_list_transaction_1.EIP2930AccessListTransaction.fromTxData(txData, common, extra);
            default:
                throw new ethereum_utils_1.CodedError(`Transactions with supplied type ${txType} not supported`, utils_1.JsonRpcErrorCode.METHOD_NOT_FOUND);
        }
    }
    /**
     * Create a transaction from a `txData` object
     *
     * When transaction types are activated (EIP 2718) the txData will be checked
     * for a transaction envelope (first byte < 192) before determining the
     * decoding strategy, otherwise it will be decoded as a Legacy Transaction. If
     * the transaction contains a transaction envelop, but EIP 2718 is not active
     * decoding will fail and an exception will be thrown.
     *
     * @param txData - The raw hex string transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
     * @param common - Options to pass on to the constructor of the transaction
     */
    static fromString(txData, common) {
        let data = utils_1.Data.toBuffer(txData);
        const type = data[0];
        const txType = this.typeOf(type);
        let tx;
        if (common.isActivatedEIP(2718)) {
            let raw;
            try {
                raw = (0, rlp_1.decode)(txType === rpc_transaction_1.TransactionType.Legacy ? data : data.slice(1));
            }
            catch (e) {
                throw new Error("Could not decode transaction: " + e.message);
            }
            tx = this._fromUnsafeUserData(raw, txType, common);
        }
        else {
            let raw;
            try {
                raw = (0, rlp_1.decode)(data);
            }
            catch (e) {
                throw new Error("Could not decode transaction: " + e.message);
            }
            tx = this._fromUnsafeUserData(raw, rpc_transaction_1.TransactionType.Legacy, common);
        }
        assertValidTransactionSValue(common, tx);
        return tx;
    }
    static typeOf(type) {
        if (type === rpc_transaction_1.TransactionType.EIP1559AccessList ||
            type === rpc_transaction_1.TransactionType.EIP2930AccessList) {
            return type;
        }
        else {
            return rpc_transaction_1.TransactionType.Legacy;
        }
    }
    /**
     * Pulls the type out of the raw transaction data, which is the first byte of
     * the raw data, unless the data is a legacy transaction (raw.length === 9),
     * in which case the type is `0`.
     *
     * This does not validate the type, it just returns it.
     *
     * @param raw
     * @returns
     */
    static typeOfRaw(raw) {
        // LegacyTransactions won't have the type up front to parse
        if (raw.length === 9) {
            return rpc_transaction_1.TransactionType.Legacy;
        }
        return raw[0][0];
    }
    static typeOfRPC(rpc) {
        if (!("type" in rpc) || rpc.type === undefined) {
            return rpc_transaction_1.TransactionType.Legacy;
        }
        else {
            // The type must be a hex value
            const txType = parseInt(rpc.type, 16);
            return this.typeOf(txType);
        }
    }
}
exports.TransactionFactory = TransactionFactory;
//# sourceMappingURL=transaction-factory.js.map