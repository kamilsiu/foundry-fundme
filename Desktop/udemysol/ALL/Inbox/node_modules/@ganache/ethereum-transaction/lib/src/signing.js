"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeIntrinsicsFeeMarketTx = exports.computeIntrinsicsAccessListTx = exports.digestWithPrefix = exports.encodeWithPrefix = exports.computeIntrinsicsLegacyTx = exports.computeFromAddress = exports.publicKeyConvert = exports.ecdsaRecover = exports.isValidSigRecovery = void 0;
const utils_1 = require("@ganache/utils");
const rlp_1 = require("@ganache/rlp");
const ethereum_address_1 = require("@ganache/ethereum-address");
const secp256k1_1 = __importDefault(require("@ganache/secp256k1"));
/**
 * Copies `length` bytes from `source` to the `target`, filling remaining
 * bytes beyond `length - source.length` with `0`. Fills to the left.
 *
 * ```typescript
 * const source = Buffer.from([1, 2, 3]);
 * const target = Buffer.from([9, 9, 9, 9, 9, 9]);
 * copyOrFill(source, target, 1, 4);
 * // target.equals(Buffer.from([9, 0, 1, 2, 3, 9]));
 * //                               ^  ^  ^  ^
 * ```
 *
 * @param source - A Buffer to copy from.
 * @param target - A Buffer to copy into.
 * @param targetStart - The offset within `target` at which to begin writing.
 * @param length - The amount of bytes to copy or fill into the `target`.
 */
function copyOrFill(source, target, targetStart, length) {
    if (source.byteLength > length)
        throw new Error("Invalid signature");
    // first, copy zeroes
    const numZeroes = length - source.byteLength;
    const endZeroes = targetStart + numZeroes;
    let i = targetStart;
    for (; i < endZeroes; i++) {
        target[i] = 0;
    }
    // then copy the source into the target:
    let end = targetStart + length;
    const sourceOffset = targetStart + numZeroes;
    for (; i < end; i++) {
        target[i] = source[i - sourceOffset];
    }
}
const isValidSigRecovery = (recovery) => {
    return recovery === 1 || recovery === 0;
};
exports.isValidSigRecovery = isValidSigRecovery;
/**
 *
 * @param sharedBuffer - A Buffer, where bytes 0 - 97 are to be used by this function
 * @param r -
 * @param s -
 * @param msgHash -
 * @param recovery -
 */
const ecdsaRecover = (partialRlp, sharedBuffer, v, chainId, rBuf, sBuf) => {
    let data;
    let recid;
    const eip155V = chainId * 2n + 35n;
    const isEip155 = v === eip155V || v === eip155V + 1n;
    if (isEip155) {
        const chainBuf = (0, utils_1.bigIntToBuffer)(chainId);
        const extras = [chainBuf, utils_1.BUFFER_EMPTY, utils_1.BUFFER_EMPTY];
        const epilogue = (0, rlp_1.encodeRange)(extras, 0, 3);
        data = (0, rlp_1.digest)([partialRlp.output, epilogue.output], partialRlp.length + epilogue.length);
        recid = Number(v - eip155V);
    }
    else {
        data = (0, rlp_1.digest)([partialRlp.output], partialRlp.length);
        recid = Number(v) - 27;
    }
    return _ecdsaRecover(data, sharedBuffer, rBuf, sBuf, recid);
};
exports.ecdsaRecover = ecdsaRecover;
function _ecdsaRecover(data, sharedBuffer, rBuf, sBuf, recid) {
    if (!(0, exports.isValidSigRecovery)(recid)) {
        throw new Error("Invalid signature v value");
    }
    const message = (0, utils_1.keccak)(data);
    const signature = sharedBuffer.slice(0, 64);
    copyOrFill(rBuf, signature, 0, 32);
    copyOrFill(sBuf, signature, 32, 32);
    const output = sharedBuffer.slice(0, 33);
    const success = secp256k1_1.default.ecdsaRecover(output, signature, recid, message);
    if (success !== 0) {
        throw new Error("Invalid Signature");
    }
    return output;
}
/**
 *
 * @param sharedBuffer - A Buffer, bytes 0 - 65 will be overwritten
 * @param senderPubKey -
 */
const publicKeyConvert = (sharedBuffer, senderPubKey) => {
    const publicKey = sharedBuffer.slice(0, 65);
    const result = secp256k1_1.default.publicKeyConvert(publicKey, senderPubKey);
    if (result !== 0) {
        throw new Error("Invalid Signature");
    }
    return publicKey;
};
exports.publicKeyConvert = publicKeyConvert;
/**
 * A Buffer that can be reused by `computeFromAddress`.
 */
const SHARED_BUFFER = Buffer.allocUnsafe(65);
const computeFromAddress = (partialRlp, v, rBuf, sBuf, chainId) => {
    const senderPubKey = (0, exports.ecdsaRecover)(partialRlp, SHARED_BUFFER, v, chainId, rBuf, sBuf);
    const publicKey = (0, exports.publicKeyConvert)(SHARED_BUFFER, senderPubKey);
    return ethereum_address_1.Address.from((0, utils_1.keccak)(publicKey.slice(1)).slice(-20));
};
exports.computeFromAddress = computeFromAddress;
const computeIntrinsicsLegacyTx = (v, raw, chainId) => {
    const encodedData = (0, rlp_1.encodeRange)(raw, 0, 6);
    const encodedSignature = (0, rlp_1.encodeRange)(raw, 6, 3);
    const ranges = [encodedData.output, encodedSignature.output];
    const length = encodedData.length + encodedSignature.length;
    const serialized = (0, rlp_1.digest)(ranges, length);
    return {
        from: (0, exports.computeFromAddress)(encodedData, v.toBigInt(), raw[7], raw[8], chainId),
        hash: utils_1.Data.from((0, utils_1.keccak)(serialized), 32),
        serialized
    };
};
exports.computeIntrinsicsLegacyTx = computeIntrinsicsLegacyTx;
/**
 * Allocates a buffer of size + 1, to be used by `digest`.
 * The extra byte is used to store the transaction type.
 * The tx type is stored in the first byte of the buffer.
 * @param size
 * @returns
 */
const allocUnsafePrefix = (size) => Buffer.allocUnsafe(size + 1);
/**
 * Encodes the given `raw` data and prepends the `prefix` to the output Buffer.
 * @param prefix must be smaller than 0x7f https://eips.ethereum.org/EIPS/eip-2718#transactiontype-only-goes-up-to-0x7f
 * @param raw
 * @returns
 */
const encodeWithPrefix = (prefix, raw) => {
    const encodedData = (0, rlp_1.encodeRange)(raw, 0, raw.length);
    const ranges = [encodedData.output];
    const length = encodedData.length;
    return (0, exports.digestWithPrefix)(prefix, ranges, length);
};
exports.encodeWithPrefix = encodeWithPrefix;
/**
 * Digests the rlp `ranges` and prepends the `prefix` to the output Buffer.
 *
 * This function avoids the need to copy the output of `digest` into a new
 * prefixed buffer by over provisioning the initial output buffer.
 * @param prefix must be smaller than 0x7f https://eips.ethereum.org/EIPS/eip-2718#transactiontype-only-goes-up-to-0x7f
 * @param ranges
 * @param length
 * @returns
 */
const digestWithPrefix = (prefix, ranges, length) => {
    // digest the ranges using the provided allocUnsafe function at an offset of `1`
    const output = (0, rlp_1.digest)(ranges, length, 1, allocUnsafePrefix);
    // set the first byte to the prefix
    output[0] = prefix;
    return output;
};
exports.digestWithPrefix = digestWithPrefix;
const computeIntrinsicsAccessListTx = (v, raw) => {
    const encodedData = (0, rlp_1.encodeRange)(raw, 0, 8);
    const encodedSignature = (0, rlp_1.encodeRange)(raw, 8, 3);
    const ranges = [encodedData.output, encodedSignature.output];
    const length = encodedData.length + encodedSignature.length;
    const serialized = (0, exports.digestWithPrefix)(1, ranges, length);
    const data = (0, exports.digestWithPrefix)(1, [encodedData.output], encodedData.length);
    const senderPubKey = _ecdsaRecover(data, SHARED_BUFFER, raw[9], raw[10], v.toNumber());
    const publicKey = (0, exports.publicKeyConvert)(SHARED_BUFFER, senderPubKey);
    const from = ethereum_address_1.Address.from((0, utils_1.keccak)(publicKey.subarray(1)).subarray(-20));
    return {
        from: from,
        hash: utils_1.Data.from((0, utils_1.keccak)(serialized), 32),
        serialized
    };
};
exports.computeIntrinsicsAccessListTx = computeIntrinsicsAccessListTx;
const computeIntrinsicsFeeMarketTx = (v, raw) => {
    const encodedData = (0, rlp_1.encodeRange)(raw, 0, 9);
    const encodedSignature = (0, rlp_1.encodeRange)(raw, 9, 3);
    const ranges = [encodedData.output, encodedSignature.output];
    const length = encodedData.length + encodedSignature.length;
    const serialized = (0, exports.digestWithPrefix)(2, ranges, length);
    const data = (0, exports.digestWithPrefix)(2, [encodedData.output], encodedData.length);
    const senderPubKey = _ecdsaRecover(data, SHARED_BUFFER, raw[10], raw[11], v.toNumber());
    const publicKey = (0, exports.publicKeyConvert)(SHARED_BUFFER, senderPubKey);
    const from = ethereum_address_1.Address.from((0, utils_1.keccak)(publicKey.slice(1)).slice(-20));
    return {
        from: from,
        hash: utils_1.Data.from((0, utils_1.keccak)(serialized), 32),
        serialized
    };
};
exports.computeIntrinsicsFeeMarketTx = computeIntrinsicsFeeMarketTx;
//# sourceMappingURL=signing.js.map