"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeBlock = exports.getBlockSize = void 0;
const utils_1 = require("@ganache/utils");
const util_1 = require("@ethereumjs/util");
const serialize_1 = require("./serialize");
const ethereum_transaction_1 = require("@ganache/ethereum-transaction");
const helpers_1 = require("./helpers");
const block_1 = require("./block");
/**
 * Returns the size of the serialized data as it would have been calculated had
 * we stored things geth does, i.e., `totalDifficulty` is not usually stored in
 * the block header.
 *
 * @param serialized -
 * @param totalDifficulty -
 */
function getBlockSize(serialized, totalDifficulty) {
    return serialized.length - totalDifficulty.length;
}
exports.getBlockSize = getBlockSize;
/**
 * A minimal block that can be used by the EVM to run transactions.
 */
class RuntimeBlock {
    constructor(common, number, parentHash, coinbase, gasLimit, gasUsed, timestamp, difficulty, previousBlockTotalDifficulty, mixHash, baseFeePerGas, withdrawalsRoot) {
        this._common = common;
        this.header = {
            parentHash: parentHash.toBuffer(),
            coinbase: coinbase,
            number: number.toBigInt(),
            difficulty: difficulty.toBigInt(),
            totalDifficulty: utils_1.Quantity.toBuffer(previousBlockTotalDifficulty.toBigInt() + difficulty.toBigInt()),
            gasLimit: gasLimit.toBigInt(),
            gasUsed: gasUsed.toBigInt(),
            timestamp: timestamp.toBigInt(),
            baseFeePerGas,
            mixHash,
            prevRandao: mixHash,
            withdrawalsRoot,
            // fixes https://github.com/trufflesuite/ganache/issues/4359
            cliqueSigner: () => coinbase
        };
    }
    /**
     * Returns the serialization of all block data, the hash of the block header,
     * and a map of the hashed and raw storage keys
     */
    finalize(transactionsTrie, receiptTrie, bloom, stateRoot, gasUsed, extraData, transactions, storageKeys) {
        const { header } = this;
        const rawHeader = [
            header.parentHash,
            util_1.KECCAK256_RLP_ARRAY,
            header.coinbase.buf,
            stateRoot,
            transactionsTrie,
            receiptTrie,
            bloom,
            utils_1.Quantity.toBuffer(header.difficulty),
            utils_1.Quantity.toBuffer(header.number),
            utils_1.Quantity.toBuffer(header.gasLimit),
            gasUsed === 0n ? utils_1.BUFFER_EMPTY : utils_1.Quantity.toBuffer(gasUsed),
            utils_1.Quantity.toBuffer(header.timestamp),
            extraData.toBuffer(),
            header.mixHash,
            utils_1.BUFFER_8_ZERO // nonce
        ];
        const isEip4895 = this._common.isActivatedEIP(4895);
        // baseFeePerGas was added in London
        if (header.baseFeePerGas !== undefined) {
            rawHeader[15] = utils_1.Quantity.toBuffer(header.baseFeePerGas, false);
            // withdrawalsRoot was added in Shanghai
            if (isEip4895)
                rawHeader[16] = utils_1.Data.toBuffer(header.withdrawalsRoot);
        }
        const { totalDifficulty } = header;
        const txs = Array(transactions.length);
        const extraTxs = Array(transactions.length);
        for (let i = 0; i < transactions.length; i++) {
            const tx = transactions[i];
            txs[i] =
                tx.raw.length === 9
                    ? tx.raw // legacy transactions don't have their own encoding
                    : tx.serialized ?? (0, ethereum_transaction_1.encodeWithPrefix)(tx.type.toNumber(), tx.raw);
            extraTxs[i] = [tx.from.toBuffer(), tx.hash.toBuffer()];
        }
        const rawBlock = isEip4895
            ? [rawHeader, txs, [], []]
            : [rawHeader, txs, []];
        const { serialized, size } = (0, serialize_1.serialize)(rawBlock, [
            totalDifficulty,
            extraTxs
        ]);
        // make a new block, but pass `null` so it doesn't do the extra
        // deserialization work since we already have everything in a deserialized
        // state here. We'll just set it ourselves by reaching into the "_private"
        // fields.
        const block = new block_1.Block(null, this._common);
        block._raw = rawHeader;
        block._rawTransactions = txs;
        block.header = (0, helpers_1.makeHeader)(rawHeader, totalDifficulty);
        block._rawWithdrawals = [];
        block._rawTransactionMetaData = extraTxs;
        block._size = size;
        return {
            block: block,
            serialized,
            storageKeys,
            transactions
        };
    }
}
exports.RuntimeBlock = RuntimeBlock;
//# sourceMappingURL=runtime-block.js.map