"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = void 0;
const utils_1 = require("@ganache/utils");
const ethereum_transaction_1 = require("@ganache/ethereum-transaction");
const rlp_1 = require("@ganache/rlp");
const helpers_1 = require("./helpers");
const utils_2 = require("@ganache/utils");
const serialize_1 = require("./serialize");
const block_params_1 = require("./block-params");
class Block {
    constructor(serialized, common) {
        this._common = common;
        if (serialized) {
            const deserialized = (0, rlp_1.decode)(serialized);
            this._raw = deserialized[0];
            this._rawTransactions = deserialized[1] || [];
            // TODO: support actual uncle data (needed for forking!)
            // Issue: https://github.com/trufflesuite/ganache/issues/786
            // const uncles = deserialized[2];
            let totalDifficulty;
            // if there are 7 serialized fields we are after shanghai
            // as in shanghai we added `withdrawals` to the block data
            if (deserialized.length === 7) {
                this._rawWithdrawals = deserialized[3] || []; // added in Shanghai
                totalDifficulty = deserialized[4];
                this._rawTransactionMetaData = deserialized[5] || [];
                this._size = utils_1.Quantity.toNumber(deserialized[6]);
            }
            else {
                this._rawWithdrawals = null;
                totalDifficulty = deserialized[3];
                this._rawTransactionMetaData = (deserialized[4] || []);
                this._size = utils_1.Quantity.toNumber(deserialized[5]);
            }
            this.header = (0, helpers_1.makeHeader)(this._raw, totalDifficulty);
        }
    }
    /**
     * Migrates a serialized Block to the latest version. This should only be
     * called on serialized data from blocks created before v7.8.0.
     *
     * This migration updates the `size` value of the block to the correct value
     * by re-serializing the block for storage in the db.
     * @param serialized
     * @returns
     */
    static migrate(serialized) {
        const deserialized = (0, rlp_1.decode)(serialized);
        const start = deserialized.slice(0, 3);
        start[1] = start[1].map((oldRawTx) => {
            if (oldRawTx.length === 9) {
                return oldRawTx; // legacy transactions are fine
            }
            else {
                // `type` is always `< 0x7F`, so we can yank the first byte from the
                // Buffer without having to think about conversion.
                // https://eips.ethereum.org/EIPS/eip-2718#transactiontype-only-goes-up-to-0x7f
                const type = oldRawTx[0][0];
                const raw = oldRawTx.slice(1);
                // type 1 and 2 transactions were encoded within the block as:
                // `[type, ...rawTx]` when they should have been `[type, encode(rawTx)]`
                return (0, ethereum_transaction_1.encodeWithPrefix)(type, raw);
            }
        });
        return (0, serialize_1.serialize)(start, deserialized.slice(3, 5)).serialized;
    }
    hash() {
        return (this._hash || (this._hash = utils_1.Data.from((0, utils_2.keccak)((0, rlp_1.encode)(this._raw)), 32)));
    }
    getTransactions() {
        const common = this._common;
        const blockHash = this.hash().toBuffer();
        const number = this.header.number.toBuffer();
        return this._rawTransactions.map((raw, index) => {
            const [from, hash] = this._rawTransactionMetaData[index];
            const extra = [
                from,
                hash,
                blockHash,
                number,
                utils_1.Quantity.toBuffer(index)
            ];
            return (0, serialize_1.blockTransactionFromRaw)(raw, common, extra);
        });
    }
    toJSON(includeFullTransactions) {
        const hash = this.hash();
        const txFn = this.getTxFn(includeFullTransactions);
        const hashBuffer = hash.toBuffer();
        const header = this.header;
        const number = header.number.toBuffer();
        const common = this._common;
        const transactions = this._rawTransactions.map((raw, index) => {
            const [from, hash] = this._rawTransactionMetaData[index];
            const extra = [
                from,
                hash,
                hashBuffer,
                number,
                utils_1.Quantity.toBuffer(index)
            ];
            const tx = (0, serialize_1.blockTransactionFromRaw)(raw, common, extra);
            // we could either parse the raw data to check if the tx is type 2,
            // get the maxFeePerGas and maxPriorityFeePerGas, use those to calculate
            // the effectiveGasPrice and add it to `extra` above, or we can just
            // leave it out of extra and update the effectiveGasPrice after like this
            tx.updateEffectiveGasPrice(header.baseFeePerGas?.toBigInt());
            return txFn(tx);
        });
        return {
            hash,
            ...header,
            size: utils_1.Quantity.from(this._size),
            transactions,
            uncles: [],
            // if `this._rawWithdrawals` is not set we should not include it in the
            // JSON response (`undefined` gets stripped when JSON.stringify is called).
            withdrawals: this._rawWithdrawals?.map(serialize_1.convertRawWithdrawals)
        };
    }
    getTxFn(include = false) {
        if (include) {
            return (tx) => tx.toJSON(this._common);
        }
        else {
            return (tx) => tx.hash;
        }
    }
    static calcNextBaseFeeBigInt(parentHeader) {
        let nextBaseFee;
        const header = parentHeader;
        const parentGasTarget = header.gasLimit.toBigInt() / block_params_1.BlockParams.ELASTICITY;
        const parentGasUsed = header.gasUsed.toBigInt();
        const baseFeePerGas = header.baseFeePerGas
            ? header.baseFeePerGas.toBigInt()
            : block_params_1.BlockParams.INITIAL_BASE_FEE_PER_GAS;
        if (parentGasTarget === parentGasUsed) {
            // If the parent gasUsed is the same as the target, the baseFee remains unchanged.
            nextBaseFee = baseFeePerGas;
        }
        else if (parentGasUsed > parentGasTarget) {
            // If the parent block used more gas than its target, the baseFee should increase.
            const gasUsedDelta = parentGasUsed - parentGasTarget;
            const adjustedFeeDelta = (baseFeePerGas * gasUsedDelta) /
                parentGasTarget /
                block_params_1.BlockParams.BASE_FEE_MAX_CHANGE_DENOMINATOR;
            if (adjustedFeeDelta > 1n) {
                nextBaseFee = baseFeePerGas + adjustedFeeDelta;
            }
            else {
                nextBaseFee = baseFeePerGas + 1n;
            }
        }
        else {
            // Otherwise if the parent block used less gas than its target, the baseFee should decrease.
            const gasUsedDelta = parentGasTarget - parentGasUsed;
            const adjustedFeeDelta = (baseFeePerGas * gasUsedDelta) /
                parentGasTarget /
                block_params_1.BlockParams.BASE_FEE_MAX_CHANGE_DENOMINATOR;
            nextBaseFee = baseFeePerGas - adjustedFeeDelta;
        }
        return nextBaseFee;
    }
    static calcNBlocksMaxBaseFee(blocks, parentHeader) {
        const { BASE_FEE_MAX_CHANGE_DENOMINATOR } = block_params_1.BlockParams;
        let maxPossibleBaseFee = this.calcNextBaseFeeBigInt(parentHeader);
        // we must calculate each future block's max base fee individually because
        // each block's base fee must be appropriately "floored" (Math.floor) before
        // the following block's base fee is calculated. If we don't do this we'll
        // end up with compounding rounding errors.
        // FYI: the more performant, but rounding error-prone, way is:
        // return lastMaxBlockBaseFee + (lastMaxBlockBaseFee * ((BASE_FEE_MAX_CHANGE_DENOMINATOR-1)**(blocks-1)) / ((BASE_FEE_MAX_CHANGE_DENOMINATOR)**(blocks-1)))
        while (--blocks) {
            maxPossibleBaseFee +=
                maxPossibleBaseFee / BASE_FEE_MAX_CHANGE_DENOMINATOR;
        }
        return maxPossibleBaseFee;
    }
    static calcNextBaseFee(parentBlock) {
        const header = parentBlock.header;
        if (header.baseFeePerGas === undefined) {
            return undefined;
        }
        else {
            return this.calcNextBaseFeeBigInt(header);
        }
    }
}
exports.Block = Block;
/**
 *  Base fee per gas for blocks without a parent containing a base fee per gas.
 */
Block.INITIAL_BASE_FEE_PER_GAS = block_params_1.BlockParams.INITIAL_BASE_FEE_PER_GAS;
//# sourceMappingURL=block.js.map