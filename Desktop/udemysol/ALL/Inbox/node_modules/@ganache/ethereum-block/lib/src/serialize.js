"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRawWithdrawals = exports.blockTransactionFromRaw = exports.serialize = void 0;
const ethereum_address_1 = require("@ganache/ethereum-address");
const ethereum_transaction_1 = require("@ganache/ethereum-transaction");
const rlp_1 = require("@ganache/rlp");
const utils_1 = require("@ganache/utils");
/**
 * Serializes a block to compute its size and store it in the database.
 * @param start
 * @param end
 * @returns
 */
function serialize(start, end) {
    const serializedStart = (0, rlp_1.encodeRange)(start, 0, start.length);
    const serializedLength = serializedStart.length;
    const ethereumRawBlockSize = (0, rlp_1.encodeLength)(serializedLength, 192).length;
    const size = ethereumRawBlockSize + serializedLength;
    const middle = (0, rlp_1.encodeRange)(end, 0, 2);
    const ending = (0, rlp_1.encode)((0, utils_1.uintToBuffer)(size));
    return {
        serialized: (0, rlp_1.digest)([serializedStart.output, middle.output, [ending]], serializedLength + middle.length + ending.length),
        size
    };
}
exports.serialize = serialize;
function isLegacyRawTransaction(raw) {
    return raw.length === 9;
}
/**
 * Converts a raw transaction encoded for use in a raw block into a `Transaction`
 *
 * @param raw the raw transaction data after the block has been rlp decoded.
 * @param common
 * @param extra
 * @returns
 */
function blockTransactionFromRaw(raw, common, extra) {
    let txData;
    let type;
    if (isLegacyRawTransaction(raw)) {
        // legacy txs
        type = 0;
        txData = raw;
    }
    else {
        // type 1 and 2 txs
        type = raw[0];
        txData = (0, rlp_1.decode)(raw.subarray(1));
    }
    return ethereum_transaction_1.TransactionFactory.fromSafeTypeAndTxData(type, txData, common, extra);
}
exports.blockTransactionFromRaw = blockTransactionFromRaw;
function convertRawWithdrawals([index, validatorIndex, address, amount]) {
    return {
        index: utils_1.Quantity.from(index),
        validatorIndex: utils_1.Quantity.from(validatorIndex),
        address: ethereum_address_1.Address.from(address),
        amount: utils_1.Quantity.from(amount)
    };
}
exports.convertRawWithdrawals = convertRawWithdrawals;
//# sourceMappingURL=serialize.js.map