"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.center = exports.highlight = exports.applyDefaults = exports.wrapWidth = void 0;
const marked_1 = require("marked");
const marked_terminal_1 = __importDefault(require("marked-terminal"));
const chalk_1 = __importDefault(require("chalk"));
const yargs_1 = __importDefault(require("yargs"));
const os_1 = require("os");
const colors_1 = require("@ganache/colors");
marked_1.marked.setOptions({
    renderer: new marked_terminal_1.default({
        codespan: chalk_1.default.hex(colors_1.TruffleColors.porsche),
        // Disable `unescape` since doesn't work for everything (we just do it ourselves)
        unescape: false
    })
});
exports.wrapWidth = Math.min(120, yargs_1.default.terminalWidth());
const addAliases = (args, aliases, key) => {
    const options = { hidden: true, alias: key };
    return aliases.reduce((args, a) => args.option(a, options), args);
};
function applyDefaults(defaults, args) {
    for (const category in defaults) {
        const group = `${category[0].toUpperCase()}${category.slice(1)}:`;
        const categoryObj = defaults[category];
        const state = {};
        for (const option in categoryObj) {
            const optionObj = categoryObj[option];
            addOption(state, category, group, option, optionObj, args);
        }
    }
}
exports.applyDefaults = applyDefaults;
function unescapeEntities(html) {
    return html
        .replace(/&amp;/g, "&")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/\*\#COLON\|\*/g, ":");
}
const highlight = (t) => unescapeEntities(marked_1.marked.parseInline(t));
exports.highlight = highlight;
const center = (str, length) => " ".repeat(Math.max(0, Math.floor((exports.wrapWidth - length) / 2))) + str;
exports.center = center;
function addOption(state, category, group, option, optionObj, argv) {
    if (optionObj.disableInCLI !== true) {
        const shortHand = [];
        const legacyAliases = [];
        let description = (0, exports.highlight)(optionObj.cliDescription || "");
        if (optionObj.cliAliases) {
            optionObj.cliAliases.forEach(alias => {
                if (alias.length === 1)
                    shortHand.push(alias);
                else
                    legacyAliases.push(alias);
            });
            description = (0, chalk_1.default) `${description}${os_1.EOL}{dim deprecated aliases: ${legacyAliases
                .map(a => `--${a}`)
                .join(", ")}}`;
        }
        const generateDefaultDescription = () => {
            // default sometimes requires a config, so we supply one
            return (state[option] = optionObj.default
                ? optionObj.default(state).toString()
                : undefined);
        };
        const defaultDescription = "defaultDescription" in optionObj
            ? optionObj.defaultDescription
            : generateDefaultDescription();
        // we need to specify the type of each array so yargs properly casts
        // the types held within each array
        const { cliType } = optionObj;
        const array = cliType && cliType.startsWith("array:"); // e.g. array:string or array:number
        const type = (array
            ? cliType.slice(6) // remove the "array:" part
            : cliType);
        const options = {
            group,
            description,
            alias: shortHand,
            defaultDescription,
            array,
            type,
            choices: optionObj.cliChoices,
            coerce: optionObj.cliCoerce,
            implies: optionObj.implies
        };
        const key = `${category}.${option}`;
        // First, create *hidden* deprecated aliases...
        argv = addAliases(argv, legacyAliases, key);
        // and *then* create the main option, as options added later take precedence
        // example: `-d --wallet.seed 123` is invalid (mutally exclusive). If aliases are defined _after_
        // the main option definition the error message will be `Arguments deterministic and wallet.seed are mutually exclusive`
        // when it should be `Arguments wallet.deterministic and wallet.seed are mutually exclusive`
        argv = argv.option(key, options);
    }
}
//# sourceMappingURL=helpers.js.map