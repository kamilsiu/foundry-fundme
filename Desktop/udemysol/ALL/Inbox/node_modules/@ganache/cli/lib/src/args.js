"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expandArgs = exports.parseArgs = void 0;
const colors_1 = require("@ganache/colors");
const yargs_1 = __importDefault(require("yargs"));
const chalk_1 = __importDefault(require("chalk"));
const os_1 = require("os");
const flavors_1 = require("./flavors");
const helpers_1 = require("./helpers");
const NEED_HELP = "Need more help? Reach out to the Truffle community at";
const COMMUNITY_LINK = "https://trfl.io/support";
const OR_DOCS = "or check out our docs at";
const DOCS_LINK = "https://ganache.dev";
const parseArgs = (version, rawArgs = process.argv.slice(2)) => {
    if (rawArgs[0] === "filecoin" || rawArgs[0] === "ethereum") {
        // we used to allow the comand `ganache filecoin` and `ganache ethereum`
        // but this is weird and confusing since they aren't ""commands", per say.
        // so for backwards compatibility we'll still allow it for these two flavors
        // only, all other flavors must use the `--flavor` option.
        // replace the flavor arg with `--flavor <flavor>`
        rawArgs[1] === rawArgs[0];
        rawArgs.unshift("--flavor");
    }
    const versionUsageOutputText = (0, chalk_1.default) `{hex("${colors_1.TruffleColors.porsche}").bold ${(0, helpers_1.center)(version, version.length)}}`;
    // disable dot-notation because yargs just can't coerce args properly...
    // ...on purpose! https://github.com/yargs/yargs/issues/1021#issuecomment-352324693
    yargs_1.default
        .parserConfiguration({ "dot-notation": false })
        .strict()
        .usage(versionUsageOutputText)
        .epilogue(versionUsageOutputText +
        os_1.EOL +
        os_1.EOL +
        (0, helpers_1.center)((0, chalk_1.default) `{hex("${colors_1.TruffleColors.porsche}").bold ${NEED_HELP}} {hex("${colors_1.TruffleColors.turquoise}") ${COMMUNITY_LINK}}`, (NEED_HELP + " " + COMMUNITY_LINK).length) +
        os_1.EOL +
        (0, helpers_1.center)((0, chalk_1.default) `{hex("${colors_1.TruffleColors.porsche}").bold ${OR_DOCS}} {hex("${colors_1.TruffleColors.turquoise}") ${DOCS_LINK}}`, (OR_DOCS + " " + DOCS_LINK).length));
    const { flavor, options: flavorOptions } = (0, flavors_1.loadFlavorFromArgs)(rawArgs);
    (0, flavors_1.configureStartCommandForFlavor)(yargs_1.default, flavor, flavorOptions);
    yargs_1.default
        .command("instances", (0, helpers_1.highlight)("Manage instances of Ganache running in detached mode." +
        os_1.EOL +
        "(Ganache can be run in detached mode by providing the `--detach` flag)"), _yargs => {
        _yargs
            .command("list", "List instances running in detached mode", _ => { }, listArgs => {
            listArgs.action = "list";
        })
            .command("stop <name>", "Stop the instance specified by <name>", stopArgs => {
            stopArgs.positional("name", { type: "string" });
        }, stopArgs => {
            stopArgs.action = "stop";
        })
            .version(false);
    }, function () {
        // this handler executes when `ganache instances` is called without a subcommand
        const command = (0, chalk_1.default) `{hex("${colors_1.TruffleColors.porsche}") ganache instances}`;
        console.log(`Missing subcommand for ${command}.`);
        console.log();
        yargs_1.default.showHelp();
        yargs_1.default.exit(1, new Error("No subcommand provided"));
    })
        .showHelpOnFail(false)
        .alias("help", "?")
        .wrap(helpers_1.wrapWidth)
        .version(version);
    const parsedArgs = yargs_1.default.parse(rawArgs);
    let finalArgs;
    if (parsedArgs.action === "stop") {
        finalArgs = {
            action: "stop",
            name: parsedArgs.name
        };
    }
    else if (parsedArgs.action === "list") {
        finalArgs = { action: "list" };
    }
    else if (parsedArgs.action === "start" ||
        parsedArgs.action === "start-detached") {
        const action = parsedArgs.action;
        const flavor = (parsedArgs.flavor || "ethereum");
        finalArgs = {
            flavor,
            action,
            ...expandArgs(parsedArgs)
        };
    }
    else {
        throw new Error(`Unknown action: ${parsedArgs.action}`);
    }
    return finalArgs;
};
exports.parseArgs = parseArgs;
/**
 * Expands the arguments into an object including only namespaced keys from the
 * `args` argument.
 * @param  {object} args to be expanded
 * @returns {object} with the expanded arguments
 */
function expandArgs(args) {
    const namespacedArgs = {};
    for (const key in args) {
        // ignore keys that are kebab-cased - they will be duplicated as camelCase
        if (key.indexOf("-") === -1) {
            // split on the first "."
            const [namespace, option] = key.split(/\.(.+)/);
            // only copy namespaced/group keys, and ignore keys with kebab cases
            if (option) {
                if (!namespacedArgs[namespace]) {
                    namespacedArgs[namespace] = {};
                }
                namespacedArgs[namespace][option] = args[key];
            }
        }
    }
    return namespacedArgs;
}
exports.expandArgs = expandArgs;
//# sourceMappingURL=args.js.map