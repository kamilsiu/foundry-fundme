"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionsConfig = void 0;
const utils_1 = require("@ganache/utils");
const checkForConflicts = (name, namespace, suppliedOptions, conflicts) => {
    if (!conflicts)
        return;
    for (const conflict of conflicts) {
        if (suppliedOptions.has(conflict)) {
            throw new Error(`Values for both "${namespace}.${name}" and ` +
                `"${namespace}.${conflict}" cannot ` +
                `be specified; they are mutually exclusive.`);
        }
    }
};
function fill(options, target, def, namespace) {
    const config = (target[namespace] = target[namespace] || {});
    const suppliedOptions = new Set();
    const entries = Object.entries(def);
    if ((0, utils_1.hasOwn)(options, namespace)) {
        const namespaceOptions = options[namespace];
        for (const [key, propDefinition] of entries) {
            let value = namespaceOptions[key];
            if (value !== undefined) {
                const normalized = propDefinition.normalize(value, config);
                if (normalized !== undefined) {
                    checkForConflicts(key, namespace, suppliedOptions, propDefinition.conflicts);
                    config[key] = normalized;
                    suppliedOptions.add(key);
                }
            }
            else {
                const legacyName = propDefinition.legacyName || key;
                value = options[legacyName];
                if (value !== undefined) {
                    const normalized = propDefinition.normalize(value, config);
                    if (normalized !== undefined) {
                        checkForConflicts(key, namespace, suppliedOptions, propDefinition.conflicts);
                        config[key] = normalized;
                        suppliedOptions.add(key);
                    }
                }
                else if ((0, utils_1.hasOwn)(propDefinition, "default")) {
                    config[key] = propDefinition.default(config);
                }
            }
        }
    }
    else {
        for (const [key, propDefinition] of entries) {
            const legacyName = propDefinition.legacyName || key;
            const value = options[legacyName];
            if (value !== undefined) {
                const normalized = propDefinition.normalize(value, config);
                if (normalized !== undefined) {
                    checkForConflicts(key, namespace, suppliedOptions, propDefinition.conflicts);
                    config[key] = normalized;
                    suppliedOptions.add(key);
                }
            }
            else if ((0, utils_1.hasOwn)(propDefinition, "default")) {
                config[key] = propDefinition.default(config);
            }
        }
    }
}
class OptionsConfig {
    constructor(defaults) {
        this.defaults = defaults;
    }
    normalize(options) {
        const out = {};
        Object.entries(this.defaults).forEach(([namespace, definition]) => {
            fill(options, out, definition, namespace);
        });
        return out;
    }
}
exports.OptionsConfig = OptionsConfig;
//# sourceMappingURL=create.js.map