"use strict";
/*!
 * @ganache/ethereum
 *
 * @author David Murdoch <david@trufflesuite.com> (https://davidmurdoch.com)
 * @license MIT
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const colors_1 = require("@ganache/colors");
const utils_1 = require("@ganache/utils");
const util_1 = require("@ethereumjs/util");
const ethereum_options_1 = require("@ganache/ethereum-options");
const flavor_1 = require("@ganache/flavor");
const connector_1 = require("./src/connector");
__exportStar(require("./src/connector"), exports);
__exportStar(require("./src/api-types"), exports);
function capitalizeFirstLetter(string) {
    return string[0].toUpperCase() + string.slice(1);
}
function color(str) {
    return (0, chalk_1.default) `{hex("${colors_1.TruffleColors.porsche}") ${str}}`;
}
const EthereumFlavor = {
    flavor: "ethereum",
    connect: (options, executor) => new connector_1.Connector(options, executor),
    options: {
        provider: ethereum_options_1.EthereumOptionsConfig,
        server: flavor_1.ServerOptionsConfig,
        cli: flavor_1.CliOptionsConfig
    },
    ready
};
// flavors are exported as a default export
exports.default = EthereumFlavor;
function ready({ provider, options }) {
    const liveOptions = provider.getOptions();
    const accounts = provider.getInitialAccounts();
    const addresses = Object.keys(accounts);
    const logs = [];
    logs.push("");
    logs.push("Available Accounts");
    logs.push("==================");
    if (addresses.length > 0) {
        addresses.forEach(function (address, index) {
            const balance = accounts[address].balance;
            const strBalance = balance / utils_1.WEI;
            const about = balance % utils_1.WEI === 0n ? "" : "~";
            let line = `(${index}) ${(0, util_1.toChecksumAddress)(address)} (${about}${strBalance} ETH)`;
            if (!accounts[address].unlocked) {
                line += " ðŸ”’";
            }
            logs.push(line);
        });
        logs.push("");
        logs.push("Private Keys");
        logs.push("==================");
        addresses.forEach(function (address, index) {
            logs.push(`(${index}) ${accounts[address].secretKey}`);
        });
        if (liveOptions.wallet.accountKeysPath != null) {
            logs.push("");
            logs.push(`Accounts and keys saved to ${liveOptions.wallet.accountKeysPath}`);
        }
    }
    else {
        logs.push("(no accounts unlocked)");
    }
    if (liveOptions.wallet.accounts == null) {
        logs.push("");
        logs.push("HD Wallet");
        logs.push("==================");
        logs.push(`Mnemonic:      ${color(liveOptions.wallet.mnemonic)}`);
        logs.push(`Base HD Path:  ${color(liveOptions.wallet.hdPath.join("/") + "/{account_index}")}`);
    }
    if (liveOptions.miner.defaultGasPrice) {
        logs.push("");
        logs.push("Default Gas Price");
        logs.push("==================");
        logs.push(color(liveOptions.miner.defaultGasPrice.toBigInt().toString()));
    }
    if (liveOptions.miner.blockGasLimit) {
        logs.push("");
        logs.push("BlockGas Limit");
        logs.push("==================");
        logs.push(color(liveOptions.miner.blockGasLimit.toBigInt().toString()));
    }
    if (liveOptions.miner.callGasLimit) {
        logs.push("");
        logs.push("Call Gas Limit");
        logs.push("==================");
        logs.push(color(liveOptions.miner.callGasLimit.toBigInt().toString()));
    }
    if (liveOptions.fork.network || liveOptions.fork.url) {
        logs.push("");
        logs.push("Forked Chain");
        logs.push("==================");
        let location;
        if (liveOptions.fork.network) {
            location = `Ethereum ${capitalizeFirstLetter(liveOptions.fork.network.replace("goerli", "gÃ¶rli"))}, via ${(0, chalk_1.default) `{hex("${colors_1.TruffleColors.infura}") ä¸•Infura}`}`;
        }
        else {
            location = liveOptions.fork.url.toString();
        }
        logs.push(`Location:        ${color(location)}`);
        logs.push(`Block:           ${color(liveOptions.fork.blockNumber.toString())}`);
        logs.push(`Network ID:      ${color(liveOptions.chain.networkId.toString())}`);
        logs.push(`Time:            ${color(liveOptions.chain.time.toString())}`);
        if (liveOptions.fork.requestsPerSecond !== 0) {
            logs.push(`Requests/Second: ${color(liveOptions.fork.requestsPerSecond.toString())}`);
        }
    }
    logs.push("");
    logs.push("Chain");
    logs.push("==================");
    logs.push(`Hardfork: ${color(liveOptions.chain.hardfork)}`);
    logs.push(`Id:       ${color(liveOptions.chain.chainId.toString())}`);
    logs.push("");
    logs.push("RPC Listening on " + options.server.host + ":" + options.server.port);
    console.log(logs.join("\n"));
}
//# sourceMappingURL=index.js.map